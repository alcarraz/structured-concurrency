\section{Scoped Values}

\begin{frame}[fragile,plain]
\begin{minted}[fontsize=\scriptsize]{java}
@SuppressWarnings("ALL")
public class ScopedPaymentProcessor {
    public static final ScopedValue<TransactionRequest> TRANSACTION_REQUEST = ScopedValue.newInstance();
    public TransactionResult processTransaction(TransactionRequest request) {
        return ScopedValue.where(TRANSACTION_REQUEST, request).call(() -> {
            ValidationResult cardResult = cardValidationService.validate();
            if (!cardResult.success()) {
                auditLog("Transaction failed: " + cardResult.message());
                return TransactionResult.failure(cardResult.message());
            }
            try (var scope = StructuredTaskScope.open(StructuredTaskScope.Joiner.awaitAll())) {
                var balanceTask = scope.fork(balanceService::validate);  // ¡Sin parámetros!
                // ... más validaciones
                scope.join();
                checkResults(xxx);
                ValidationResult debitResult = balanceService.debit();
                return debitResult.success() ? TransactionResult.success(xxx) : TransactionResult.failure(xxx);
            }
        });
    }
}
\end{minted}
\end{frame}

\begin{frame}[fragile,plain]
\begin{minted}[fontsize=\footnotesize]{java}
// Acceso automático al request - sin parameter drilling
public class ScopedBalanceService {
    public ValidationResult validate() {
        TransactionRequest request = ScopedPaymentProcessor.TRANSACTION_REQUEST.get();  // ¡Sin parámetros!
        String cardNumber = request.cardNumber();
        auditLog("Starting balance validation for card: " + cardNumber.substring(cardNumber.length() - 4));

        DemoUtil.simulateNetworkDelay(500);

        if (request.amount().doubleValue() > 1000) {
            auditLog("Balance validation failed: Insufficient funds");
            return ValidationResult.failure("Balance Check: Insufficient funds");
        }

        auditLog("Balance validation successful");
        return ValidationResult.success("Balance Check: Validation successful");
    }

    public ValidationResult debit() {
        TransactionRequest request = ScopedPaymentProcessor.TRANSACTION_REQUEST.get();
        String cardNumber = request.cardNumber();
        auditLog("Starting debit for card: " + cardNumber.substring(cardNumber.length() - 4));
        DemoUtil.simulateNetworkDelay(300);
        return ValidationResult.success("Balance Debit: Amount successfully debited");
    }

    private void auditLog(String message) {
        TransactionRequest request = ScopedPaymentProcessor.TRANSACTION_REQUEST.get();  // Automático!
        System.out.println("BALANCE [Customer: " + request.customerId() + "] " + message);
    }
}
\end{minted}

\vspace{1em}
\begin{alertblock}{$\blacktriangleright$ ¡Scoped Values son ESTABLES en Java 25!}
\textbf{Adopten HOY en producción.} No más ThreadLocal ni parameter drilling.
\textcolor{green}{\textbf{JEP 506 - FINAL}} - Context propagation thread-safe automático.
\end{alertblock}
\end{frame}

